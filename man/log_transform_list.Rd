% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{log_transform_list}
\alias{log_transform_list}
\title{log2(x+1) / Batch decide & apply log2(x+1)}
\usage{
log_transform_list(
  exp_list,
  forces = NULL,
  integer_prop_threshold = 0.995,
  mean_threshold = 1,
  max_threshold = 100,
  tol = 1e-08,
  q_hi_prob = 0.99,
  q_hi_threshold = 20,
  frac_nonint_threshold = 0.2,
  verbose = TRUE
)
}
\arguments{
\item{exp_list}{A list of matrices or data frames. Each element is treated as an expression-like matrix.}

\item{forces}{\code{length(exp_list)}
\verb{"auto"``"always"``"never"} \code{"auto"}
Optional character vector of length \code{length(exp_list)}, with values
\code{"auto"}, \code{"always"}, or \code{"never"}. Defaults to \code{"auto"} for all datasets.
\code{"auto"} log
\code{"auto"}: decide via heuristics
\code{"always"} \code{log2(x+1)}
\code{"always"}: unconditionally apply \code{log2(x+1)}
\code{"never"}
\code{"never"}: keep original scale unconditionally}

\item{integer_prop_threshold}{0.995
Proportion threshold of near-integer values for count-likeness (default 0.995).}

\item{mean_threshold}{1
Minimum mean used for count-likeness (default 1).}

\item{max_threshold}{100
Maximum value threshold supporting count-likeness (default 100).}

\item{tol}{1e-8
Numeric tolerance for near-integer checks (default 1e-8).}

\item{q_hi_prob}{"log" 0.99
High-quantile probability for log-likeness (default 0.99).}

\item{q_hi_threshold}{"log" 20
Threshold for the high quantile when assessing log-likeness (default 20).}

\item{frac_nonint_threshold}{"log" 0.2
Fraction of non-integer values required for log-likeness (default 0.2).}

\item{verbose}{TRUE
Whether to print progress messages for each dataset (default TRUE).}
}
\value{
A list with two elements:
\item{data}{ \code{exp_list} \code{log2(x+1)}
A list of transformed (or original) matrices, same length as \code{exp_list}.}
\item{report}{\code{data.frame}
A \code{data.frame} summarizing decisions with columns:
\itemize{
\item \code{dataset}: / dataset name
\item \code{rows}, \code{cols}: / dimensions
\item \code{mean}, \code{max}: / mean and max over finite entries
\item \code{integer_prop}: \code{tol} / proportion of near-integers
\item \code{is_count_like}: / count-like flag
\item \code{is_logged_like}: log / log-like flag
\item \code{need_log2p1}: \code{log2(x+1)} / whether transformation applied
}}
}
\description{
\code{exp_list} /
\code{log2(x + 1)}
For each matrix/data frame in \code{exp_list}, this function heuristically decides
whether a log transformation is needed and, if so, applies \code{log2(x + 1)}.
It also returns a per-dataset decision/summary report.
}
\details{
/ \code{decide_log_for_matrix()}
\code{is_count_like()} \code{is_logged_like()}
"log" \code{log2(x+1)}
\code{forces} \code{"always"} \code{"never"}
The decision scheme delegates to \code{decide_log_for_matrix()}, which uses
\code{is_count_like()} and \code{is_logged_like()} heuristics. A dataset is
transformed if it is count-like and not already log-like. The \code{forces}
argument overrides automatic decisions.
}
\examples{
\dontrun{
lst <- list(A = matrix(c(0,1,3,10), 2),
B = matrix(rnorm(6, 5, 1), 2))
res <- log_transform_list(lst)
res$report
}
}
\seealso{
\code{\link{decide_log_for_matrix}}, \code{\link{is_count_like}}, \code{\link{is_logged_like}}
}
